
📘 Day13｜今日やったことの完全な振り返り


1️⃣ 今日のゴール

今日の目的はこれでした。

フロント（仮）から送られたデータを
Laravelが受け取り、処理し、結果を返す
「APIの1往復」を体験すること

Reactはまだ書かず、curlを仮のフロントとして使う。



2️⃣ まずやったこと：Laravelを動かす準備

Ubuntu（WSL）で Laravel を起動
./vendor/bin/sail up -d

ここで理解したこと

Laravelは サーバーとして動き続けるプログラム
-d を付けると 裏で動作する
ターミナルは 操作用として使い続けられる

👉
「サーバーは動かしっぱなし、指示は別で出す」
という基本構造を理解した。



3️⃣ ターミナルを2つ使った理由（重要な理解）

最初の混乱

Ubuntuを2つ開いた
「リクエスト側」「返ってくる側」で分けている感覚があった


最終的に理解したこと

通信（POSTとレスポンス）は1つのcurlコマンド内で完結
ターミナルを2つ使ったのは 作業上の都合

1つ：サーバー（ログ・起動）
1つ：指示（curl）

👉
「分ける必要はなかったが、分けても問題はない」
という理解に到達。



4️⃣ curl とは何かを理解した

curlの正体

URLに対してHTTP通信を送るためのコマンドラインツール


今日の位置づけ

Reactの代わり
APIに話しかけるための道具


今日使ったcurl

curl -X POST http://localhost/api/dreams \
  -H "Content-Type: application/json" \
  -d '{"title":"筋トレを習慣化"}'

この1行で起きていること

POSTリクエストを送信
JSONデータを送る
サーバーの返事を受け取る
結果を画面に表示

👉
送信と受信は同じcurlがやっている。



5️⃣ 今日のメイン：APIコードの理解

対象のコード
Route::post('/dreams', function (Request $request) {


全体の役割

夢を1件追加するAPI


処理の流れ（あなたの理解を整理した完成版）

POST /api/dreams が来る
↓
Laravelが Request として受け取る
↓
仮のデータベース（配列 $dreams）がある
↓
リクエストから title だけを取り出す

→
title が空なら：
ok: false
"title is required"
HTTPステータス 422

→
問題なければ：
↓
既存データ数 + 1 で 新しいIDを作る
↓
id と title をセットにした newDream を作成
↓
それを $dreams に追加
↓
「追加できました」というJSONを返す



6️⃣ 今日いちばん重要な理解

技術的な本質

POST → 受け取る → 処理 → 返す

この流れは DBになっても変わらない

今日の配列は DBの代役

設計としての理解

APIは「受付窓口」

curl / React は「お願いする側」

Laravel は「判断して返す側」



7️⃣ 今日の疑問と解消

疑問①

「なぜUbuntuを2つ使ったのか？」

👉
サーバーがターミナルを占拠していたため。
通信のためではない。



疑問②

「リクエスト側と返ってくる側を分けているのか？」

👉
分けていない。
curlが送って、curlが受け取って表示している。



疑問③

「curlって何？」

👉
Reactの代わりにAPIに話しかける道具。



8️⃣ 今日の学習を一文でまとめると

「フロント（仮）からPOSTでデータを送り、
Laravelがそれを受け取って処理し、
結果をJSONで返すAPIの最小構造を体験した」